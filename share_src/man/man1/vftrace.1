.TH VFTRACE "1" "MONTH YEAR" "Vftrace VERSION" "VFTRACE"
.SH NAME
vftrace \- Profiling library
.SH SYNOPSIS
.IP "\fBcompile with vftrace:\fR"
.IX Item "compile with vftrace:"
<compiler> <options> -finstrument-functions -I${VFTRACE_ROOT}/include/ -c <sourcefile> 
.IP "\fBlink with vftrace:\fR"
.IX Item "link with vftrace:"
<linker> <options> -o <executable> <objects> -L${VFTRACE_ROOT}/lib -lvftrace -lm

.SH DESCRIPTION
.\" Add any additional description here
.PP
Vftrace is a profiling library for C, C++, and Fortran programs. 
Utilizing function hooks, vftrace collects information about the callstack
timeline as well as timings and performance informations of all called functions.
It supports logging of MPI-communication via special wrapping routines.
The MPI-3.1 Standard is fully supported.
The profiling behaviour can be controlled by a set of environment variables
and library functions to be incorporated into the profiled programs source code.
.PP
.SH "PROFILING CONTROL"
.IX Header "PROFILING CONTROL"
.SS ENVIRONMENT VARIABLES
.IX Subsection "ENVIRONMENT VARIABLES"
Here is a collection of all environment variables to controll Vftrace
profiling and sampling.
.\"
.IP "\fBVFTR_BUFSIZE\fR"
.IX Item "VFTR_BUFSIZE"
Buffer size for the buffered stream output of the profiling data files (.vfd) in MiB.
.br
\fBDefault: 8\fR
.\"
.IP "\fBVFTR_INCLUDE_ONLY\fR"
.IX Item "VFTR_INCLUDE_ONLY"
A regular expression defining functions which should be profiled, while all others are excluded. The regular expression can also be a single function name. Examples:
.br
\fBVFTR_INCLUDE_ONLY=foo_bar\fR
.br
\fBVFTR_INCLUDE_ONLY=foo*\fR
.br
\fBWarning:\fR This option cannot be used with \fBVFTR_EXCLUDE\fR. If both environment variables are set, only \fBVFTR_INCLUDE_ONLY\fR is used.
.\"
.\"
.IP "\fBVFTR_LOGFILE_FOR_RANKS\fR"
.IX Item VFTR_LOGFILE_FOR_RANKS
Specifies the ranks for which a local logfile is created.
Vftrace always produces a summary logfile of the form <basename>_all.log (see \fBVFTR_LOGFILE_BASENAME\fR").
It takes a string value as argument, so the content needs to be put in quotes ("").
Possible values are "none" (no logfile for individual ranks),
"all" (logfiles for all ranks),
"X-Y" (logfiles for all ranks between X and Y),
and "X,Y,Z" (logfile only for ranks X, Y, and Z),
or a mixture of the latter two e.g. "1,4,6,15-23,25,28-29,31". 
.br
\fBDefault: "none"\fR
.\"
.IP "\fBVFTR_LOGFILE_BASENAME\fR"
.IX Item "VFTR_LOGFILE_BASENAME"
The Basename of the ASCII log files (.log) and profiling data files (.vfd).
The full name of a profiling data file is <basename>_<mpirank>.vfd
and for a logfile <basename>_<mpirank>.log, or <basename>_all.log.
.br
\fBDefault: The executable name.\fR
.\"
.IP "\fBVFTR_MPI_LOG\fR"
.IX Item "VFTR_MPI_LOG"
\fBEnable\fR(1,"YES","Yes","yes","ON","On","on")
.br
\fBDisable\fR(0,"NO","No","no","OFF","Off","off")
.br
Switches on the logging of MPI communication.
.br
\fBDefault: "off"
.\"
.IP "\fBVFTR_MPI_SHOW_SYNC_TIME\fR"
.IX Item "VFTR_MPI_SHOW_SYNC_TIME\fR"
\fBEnable\fR(1,"YES","Yes","yes","ON","On","on")
.br
\fBDisable\fR(0,"NO","No","no","OFF","Off","off")
.br
Switches on the estimation of synchronization times for blocking collective MPI communication.
These are: Allgather, Allgatherv, Allreduce, Alltoall, Alltoallv, Alltoallw, Exscan, Gather, Gatherv, Reduce, Scan, Scatter, Scatterv.
Every process measures the time it takes until all other processes arrive at the call.
The synchronization time will be measured as a seperate function call "MPI_<mpi-function-name>_sync" (e.g. MPI_Allreduce_sync).
Note that this might prevent processes from starting communication with already arrived processes.
Therefore, communication imbalances can be computed inexcact.
.br
\fBDefault: "off"
.\"
.IP "\fBVFTR_RANKS_IN_MPI_PROFILE\fR"
.IX Item "VFTR_RANKS_IN_MPI_PROFILE\fR"
Select which communications based on the sending and receiving ranks should be included in the MPI-profile.
Possible values are "all",
"X-Y" (only messages where sender and receiver are in X-Y),
and "X,Y,Z" (only messages where sender and receiver are X,Y,orZ)
or a mixture of the latter two e.g. "1,4,6,15-23,25,28-29,31". 
.br
\fBDefault: "all"
.\"
.IP "\fBVFTR_OFF\fR"
.IX Item "VFTR_OFF"
\fBDisable\fR(1,"YES","Yes","yes")
.br
\fBEnable\fR(0,"NO","No","no")
.br
Switches off Vftrace profiling. The program execution is as without Vftrace, although
it might have been linked against libvftrace. 
.br 
\fBDefault: "no"\fR
.\"
.IP "\fBVFTR_OUT_DIRECTORY\fR"
.IX Item "VFTR_OUT_DIRECTORY"
Sets the output directory for the profiling data files (.vfd) and logfiles (.log).
.br
\fBDefault: Current working directory "./"\fR
.\"
.IP "\fBVFTR_PRECISE\fR"
.IX Item "VFTR_PRECISE"
.br
A regular expression specifying which functions should be sampled precisely.
This ignores the minimum time given by \fBVFTR_SAMPLETIME\fR and registers
every function exit and entry.
Note that this potentially leads to a significant increase in profiling overhead and
output file size.
.br
\fBDefault: "off"
.\"
.IP "\fBVFTR_SAMPLETIME\fR"
.IX Item "VFTR_SAMPLETIME"
Sets the time (in seconds) between two callstack samples written into .vfd files.
This is regardless of how many functions are actually entered or exited in this interval.
The setting is ignored if \fBVFTR_PRECISE\fR is enabled.
.br
\fBDefault: "0.005"
.\"
.IP "\fBVFTR_SAMPLING\fR"
.IX Item "VFTR_SAMPLING"
\fBEnable\fR(1,"YES","Yes","yes","ON","On","on")
.br
\fBDisable\fR(0,"NO","No","no","OFF","Off","off")
.br
Enables the creation of .vfd runtime profiles. 
.br
\fBDefault: "off"\fR
.\"
.IP "\fBVFTR_SHOW_FUNCTION_OVERHEAD\fR"
.IX Item "VFTR_SHOW_FUNCTION_OVERHEAD"
\fBEnable\fR(1,"YES","Yes","yes","ON","On","on")
.br
\fBDisable\fR(0,"NO","No","no","OFF","Off","off")
.br
Display function hook overhead in profile table.
.br
\fBDefault: "off"\fR
.\"
.IP "\fBVFTR_SHOW_CALLTIME_IMBALANCES\fR"
.IX Item "VFTR_SHOW_CALLTIME_IMBALANCES"
\fBEnable\fR(1,"YES","Yes","yes","ON","On","on")
.br
\fBDisable\fR(0,"NO","No","no","OFF","Off","off")
.br
Display discrepancies in the time spend in functions across ranks to locate compute load imbalances.
.br
\fBDefault: "off"\fR
.\"
.IP "\fBVFTR_GROUP_FUNCTIONS_BY_NAME\fR"
.IX Item "VFTR_GROUP_FUNCTIONS_BY_NAME"
\fBEnable\fR(1,"YES","Yes","yes","ON","On","on")
.br
\fBDisable\fR(0,"NO","No","no","OFF","Off","off")
.br
Include an extra table in the summary logfile, where profiling information is not grouped by callstack, but by function name.
.br
\fBDefault: "off"\fR
.\"
.IP "\fBVFTR_PRINT_ENVIRONMENT\fR"
.IX Item "VFTR_PRINT_ENVIRONMENT"
\fBEnable\fR(1,"YES","Yes","yes","ON","On","on")
.br
\fBDisable\fR(0,"NO","No","no","OFF","Off","off")
.br
Append the used vftrace settings to the end of the logfile.
.br
\fBDefault: "on"\fR
.\"
.IP "\fBVFTR_CALLPATH_IN_PROFILE\fR"
.IX Item "VFTR_CALLPATH_IN_PROFILE"
\fBEnable\fR(1,"YES","Yes","yes","ON","On","on")
.br
\fBDisable\fR(0,"NO","No","no","OFF","Off","off")
.br
Include the callpath of the function in the profile table, instead of just the stacks id.
.br
\fBDefault: "off"\fR
.\"
.IP "\fBVFTR_CALLPATH_IN_MPI_PROFILE\fR"
.IX Item "VFTR_CALLPATH_IN_MPI_PROFILE"
\fBEnable\fR(1,"YES","Yes","yes","ON","On","on")
.br
\fBDisable\fR(0,"NO","No","no","OFF","Off","off")
.br
Include the callpath of the function in the mpi profile table, instead of just the stacks id.
.br
\fBDefault: "off"\fR
.\"
.\"
.IP "\fBVFTR_DEMANGLE_CXX\fR"
.IX Item "VFTR_DEMANGLE_CXX"
\fBEnable\fR(1,"YES","Yes","yes","ON","On","on")
.br
\fBDisable\fR(0,"NO","No","no","OFF","Off","off")
.br
Demangle c++ symbol names to make them more human readable. (Requires libiberty to be installed and linked)
.br
\fBDefault: "off"\fR
.\"
.IP "\fBVFTR_SCENARIO_FILE\fR"
.IX Item "VFTR_SCENARIO_FILE"
Path to the scenario file in JSON format that defines the hardware counters and event observables.
.\"
.IP "\fBVFTR_STRIP_MODULE_NAMES\fR"
.IX Item "VFTR_STRIP_MODULE_NAMES"
The symbol names for subroutines and functions defined in Fortran modules can be put together from
the module name and the function name, with a delimiter "_MP_". When this environment variable
is set, the module name is split off from the symbol, leading to shorter output, e.g. in function stacks.
Note that this way, there is no way to distinguish between functions with identical names from
different modules only by their name. Instead, the stack ID has to be used. Also, the "_MP_" delimiter
might be different, depending on the compiler or linker. In this case, the logfile output
appears as in the case where the environment variable is not set.
.\"
.IP "\fBVFTR_SORT_PROFILE_TABLE\fR"
.IX Item "VFTR_SORT_PROFILE_TABLE\fR"
Specifies how the profile table is sorted. Possible values are TIME_EXLC (exclusive time, default), 
TIME_INCL (inclusive time), CALLS (number of calls), STACK_ID, OVERHEAD, OVERHEAD_RELATIVE and NONE.
.\"
.IP "\fBVFTR_SORT_MPI_TABLE\fR"
.IX Item "VFTR_SORT_MPI_TABLE\fR"
Specifies how the mpi profile table is sorted. Possible values are TIME_EXLC (exclusive time, default),
TIME_INCL (inclusive time), CALLS (number of calls), STACK_ID, OVERHEAD, OVERHEAD_RELATIVE and NONE.
.\"
.IP "\fBVFTR_SORT_CUPTI_TABLE\fR"
.IX Item "VFTR_SORT_CUPTI_TABLE\fR"
Specifies how the cupti profile table is sorted. Possible values are TIME_EXLC (exclusive time, default),
TIME_INCL (inclusive time), CALLS (number of calls), STACK_ID, OVERHEAD, OVERHEAD_RELATIVE and NONE.
.\"
.SS LIBRARY FUNCTIONS
.IX Subsection "LIBRARY FUNCTIONS"
Vftrace provides library functions which can be included in a C or Fortran application
which allow for a more detailed profiling of it. This requires the inclusion of
\fbvftrace.h\fR (C) or the \fbvftrace\fR module (Fortran).
.br
\fBWarning:\fR If an MPI-parallel code is profiled with vftrace the
functions and routines must only be called after \fBMPI_Init\fR 
and before \fBMPI_Finalize\fR!
.\"
.IP "\fBMPI_Pcontrol(level)\fR"
.IX Item "MPI_Pcontrol"
Required by the MPI-Standard (Section 14.2.4).
Lets you control the level of the MPI-Profiling.
.br
level == 0 Profiling is disabled.
.br
level == 1 Profiling is enabled at a normal default level of detail.
.br
level == 2 Profile buffers are flushed, which may be a no-op.
.br
Changing the level between the start and the corresponding Wait/Test of a
non-blocking communication can lead to undefined behavior.
Users are encouraged to use the \fBvftr_pause\fR and \fBvftr_resume\fR routines instead.
Default level is 1.
.IP "\fBvftrace_region_begin, vftrace_region_end\fR"
.IX Item "vftrace_region_begin_end"
Define the start and end of a region in the code, which should be monitored
independently from from a function entry.
The functions take as an argument a unique string identifier.
The defined region appears in the logfile and vfd files under the this name.
.\"Working example codes can be found in the test suite.
.br
\fBExample in C:\fR
   void testfunction() {
      ...
      vftrace_region_begin("NameOfTheRegion");
      // code to be profiled independently
      ...
      // from the rest of the function
      vftrace_region_end("NameOfTheRegion");
      ...
   }
.br
\fBExample in Fortran:\fR
   SUBROUTINE testroutine()
      ...
      CALL vftrace_region_begin("NameOfTheRegion")
      ! code to be profiled independently
      ...
      ! from the rest of the routine
      CALL vftrace_region_end("NameOfTheRegion")
      ...
   END SUBROUTINE
.\"
.IP "\fBvftrace_get_stack\fR"
.IX "vftrace_get_stack"
Returns a (char*) in C and a (character(len=*), pointer) in Fortran that contains the 
current callstack.
.br
\fBExample in C:\fR
   printf("%s\\n", vftrace_get_stack());
.br
\fBExample in Fortran:\fR
   write(*,*) vftrace_get_stack()
.\"
.IP "\fBvftrace_pause, vftrace_resume\fR"
.IX Item "vftrace_pause_resume"
Pauses the monitoring and profiling until \fBvftrace_resume\fR is called.
It has no effect if the monitoring is already paused
by an earlier call to vftrace_pause.
Pausing enables to focus on specific parts of the code and to reduce the size of logfiles and vfd files,
as well as runtime.
Note that \fBvftrace_pause\fR and \fBvftrace_resume\fR do not need to appear in the same
function, routine, or even compile unit.
They take effect as soon as they are encountered during program execution.
.br
\fBExample in C:\fR
   int main() {
      // This code is profiled
      ...
      vftrace_pause();
      // This code is not profiled
      ...
      vftrace_resume();
      // This code is profiled again 
      ...
   }
.br
\fBExample in Fortran:\fR
   PROGRAM testprogram
      ! This code is profiled
      ...
      CALL vftrace_pause()
      ! This code is not profiled
      ...
      CALL vftrace_resume()
      ! This code is code profiled again
      ...
   END PROGRAM testprogram
.\"
